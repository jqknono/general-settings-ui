/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./webview/main.ts"
/*!*************************!*\
  !*** ./webview/main.ts ***!
  \*************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\nclass SettingsEditorApp {\n    constructor() {\n        // VS Code webview 与扩展通信的桥接对象\n        window.vscode = acquireVsCodeApi();\n        this.schema = null;\n        this.data = {};\n        this._baseData = {};\n        this._dirtyPaths = new Set();\n        this._dirtyCollectionPaths = new Set();\n        this._formSyncTimer = null;\n        // 用户期望“任何改动立即同步到源 JSON”，这里不再做输入防抖\n        this._formSyncDebounceMs = 0;\n        this._sessionId = `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\n        this._syncRev = 0;\n        this._lastSentRev = 0;\n        this._lastAckRev = 0;\n        this._lastSentJsonText = null;\n        this._lastSentJsonTs = 0;\n        this.currentSchemaUrl = null;\n        this._searchIndex = [];\n        this._searchResults = [];\n        this._searchSelectedIndex = -1;\n        this._searchField = null;\n        this._searchResultsEl = null;\n        this._searchWrapperEl = null;\n        this.init();\n    }\n    async init() {\n        window.addEventListener('message', (event) => {\n            this.handleMessage(event.data);\n        });\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', () => this.setupUI());\n        }\n        else {\n            this.setupUI();\n        }\n    }\n    setupUI() {\n        this._searchWrapperEl = document.getElementById('settingsSearchWrapper');\n        this._searchField = document.getElementById('settingsSearch');\n        this._searchResultsEl = document.getElementById('settingsSearchResults');\n        if (this._searchField) {\n            this._searchField.addEventListener('input', () => this.handleSearchInput());\n            this._searchField.addEventListener('keydown', (e) => this.handleSearchKeydown(e));\n            this._searchField.addEventListener('focus', () => this.maybeShowSearchResults());\n        }\n        document.addEventListener('keydown', (e) => {\n            const isFind = (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f';\n            if (isFind && this._searchField) {\n                e.preventDefault();\n                this._searchField.focus();\n            }\n        });\n        document.addEventListener('click', (e) => {\n            if (!this._searchWrapperEl || !this._searchResultsEl)\n                return;\n            const target = e.target;\n            if (!target)\n                return;\n            if (this._searchWrapperEl.contains(target))\n                return;\n            this.hideSearchResults();\n        });\n        const selectSchemaBtn = document.getElementById('selectSchemaBtn');\n        if (selectSchemaBtn) {\n            selectSchemaBtn.addEventListener('click', (e) => {\n                console.log('Select Schema button clicked');\n                e.preventDefault();\n                e.stopPropagation();\n                this.postMessage({ command: 'selectSchema' });\n            });\n        }\n        this.debugLog('webview ready: postMessage(ready)', { sessionId: this._sessionId });\n        this.postMessage({ command: 'ready', meta: { sessionId: this._sessionId, ts: Date.now() } });\n    }\n    handleMessage(message) {\n        switch (message.command) {\n            case 'loadSchema':\n                this.debugLog('recv loadSchema', {\n                    sessionId: this._sessionId,\n                    hasSchema: !!message.schema,\n                    settingsHtmlLength: message.settingsHtml ? String(message.settingsHtml).length : 0\n                });\n                this.loadSchema(message.schema, message.settingsHtml);\n                break;\n            case 'loadJson':\n                this.debugLog('recv loadJson', {\n                    sessionId: this._sessionId,\n                    length: message.json ? String(message.json).length : 0\n                });\n                // Ignore the JSON echoed back from our own write to avoid full re-render (which blurs focused inputs).\n                if (typeof message?.json === 'string' &&\n                    this._lastSentJsonText &&\n                    Date.now() - this._lastSentJsonTs < 2500) {\n                    const echoed = this.safeParseJsonText(message.json);\n                    const sent = this.safeParseJsonText(this._lastSentJsonText);\n                    if (echoed !== undefined && sent !== undefined && this.deepEqualJson(echoed, sent)) {\n                        this.debugLog('ignore loadJson (echo from self, semantically equal)', {\n                            sessionId: this._sessionId,\n                            rev: this._lastSentRev,\n                            tsDeltaMs: Date.now() - this._lastSentJsonTs\n                        });\n                        return;\n                    }\n                }\n                this.updateData(message.json);\n                break;\n            case 'boundSource':\n                this.updateBoundSource(message.source);\n                break;\n            case 'updateForm':\n                this.debugLog('recv updateForm', { sessionId: this._sessionId });\n                this.updateFormData(message.data);\n                break;\n            case 'updateJsonAck':\n                this.handleUpdateJsonAck(message.meta);\n                break;\n            case 'showError':\n                this.showError(message.error);\n                break;\n        }\n    }\n    updateBoundSource(source) {\n        const el = document.getElementById('boundSource');\n        if (!el)\n            return;\n        const fsPath = typeof source?.fsPath === 'string' ? source.fsPath : '';\n        const uri = typeof source?.uri === 'string' ? source.uri : '';\n        const isUntitled = !!source?.isUntitled;\n        const baseName = (() => {\n            const raw = fsPath || uri;\n            const parts = String(raw).split(/[\\\\/]/g).filter(Boolean);\n            return parts.length > 0 ? parts[parts.length - 1] : raw;\n        })();\n        el.textContent = isUntitled ? `Bound file: ${baseName || 'Untitled (unsaved)'}` : `Bound file: ${baseName}`;\n        el.setAttribute('title', fsPath || uri);\n    }\n    async loadSchema(schemaUrlOrObject, settingsHtml) {\n        try {\n            console.log('loadSchema called with:', schemaUrlOrObject, 'settingsHtml length:', settingsHtml?.length);\n            let schema;\n            let schemaUrl;\n            if (typeof schemaUrlOrObject === 'string') {\n                schemaUrl = schemaUrlOrObject;\n                this.postMessage({\n                    command: 'loadSchema',\n                    schemaUrl: schemaUrl\n                });\n                return;\n            }\n            else {\n                schema = schemaUrlOrObject;\n                schemaUrl = schemaUrlOrObject.url;\n            }\n            this.schema = schema;\n            this.currentSchemaUrl = schemaUrl;\n            console.log('Schema loaded, currentSchemaUrl:', this.currentSchemaUrl);\n            const titleElement = document.getElementById('schemaTitle');\n            const descriptionElement = document.getElementById('schemaDescription');\n            if (titleElement && schema.title) {\n                titleElement.textContent = schema.title;\n            }\n            if (descriptionElement && schema.description) {\n                descriptionElement.textContent = schema.description;\n            }\n            if (settingsHtml) {\n                const formEditor = document.getElementById('formEditor');\n                if (formEditor) {\n                    formEditor.innerHTML = settingsHtml;\n                    this.setupFormEventListeners();\n                    this.renderArrayObjectItemsFromData(this._baseData);\n                    this.renderMapObjectItemsFromData(this._baseData);\n                    this.updateFormInputs();\n                    this.syncAnyOfObjectsFromData(this._baseData);\n                    this.buildSearchIndex();\n                    this.handleSearchInput();\n                }\n            }\n        }\n        catch (error) {\n            console.error('Load schema failed:', error);\n            this.showError(`Failed to load schema: ${error.message}`);\n        }\n    }\n    setupFormEventListeners() {\n        const formEditor = document.getElementById('formEditor');\n        if (!formEditor)\n            return;\n        formEditor.querySelectorAll('.sidebar-item').forEach(item => {\n            item.addEventListener('click', () => {\n                const el = item;\n                const targetId = el.getAttribute('data-scroll-to') || '';\n                if (targetId) {\n                    this.activateSidebarItem(el);\n                    this.scrollToSettingId(targetId);\n                }\n            });\n        });\n        formEditor.addEventListener('change', (e) => {\n            const target = e.target;\n            if (!target)\n                return;\n            if (target.classList.contains('anyof-selector')) {\n                this.handleAnyOfSelectorChange(target);\n                return;\n            }\n            if (!target.dataset || !target.dataset.path)\n                return;\n            if (target.classList.contains('map-key-input')) {\n                const mapPath = this.getCollectionRootForControl(target);\n                const itemEl = target.closest('.map-item');\n                if (mapPath && itemEl) {\n                    this.rebindMapItem(mapPath, itemEl);\n                    this.validateMapObject(mapPath);\n                }\n            }\n            this.applyControlValidations(target);\n            this.markDirtyFromControl(target);\n            this.handleFormChange('change', target.dataset.path);\n        });\n        // 输入时立即同步（默认 change 只会在失焦后触发）\n        formEditor.addEventListener('input', (e) => {\n            const target = e.target;\n            if (!target)\n                return;\n            if (!target.dataset || !target.dataset.path)\n                return;\n            if (target.classList.contains('map-key-input')) {\n                const mapPath = this.getCollectionRootForControl(target);\n                const itemEl = target.closest('.map-item');\n                if (mapPath && itemEl) {\n                    this.rebindMapItem(mapPath, itemEl);\n                    this.validateMapObject(mapPath);\n                }\n            }\n            this.applyControlValidations(target);\n            // 避免与 change 重复触发（checkbox/select 通常已在 change 中处理）\n            const type = target.dataset.type;\n            const tag = target.tagName ? String(target.tagName).toUpperCase() : '';\n            if (type === 'boolean' || tag === 'SELECT')\n                return;\n            this.markDirtyFromControl(target);\n            this.handleFormChange('input', target.dataset.path);\n        });\n        formEditor.addEventListener('click', (e) => {\n            const target = e.target;\n            if (!target)\n                return;\n            const addBtn = target.closest('.array-add-button');\n            if (addBtn) {\n                const arrayPath = addBtn.getAttribute('data-array-path') || '';\n                if (arrayPath) {\n                    this.addArrayItem(arrayPath);\n                    this.handleFormChange('array-add', arrayPath);\n                }\n                return;\n            }\n            const removeBtn = target.closest('.array-remove-button');\n            if (removeBtn) {\n                const arrayPath = removeBtn.getAttribute('data-array-path') || '';\n                const itemEl = target.closest('.array-item');\n                if (arrayPath && itemEl) {\n                    this.removeArrayItem(arrayPath, itemEl);\n                    this.handleFormChange('array-remove', arrayPath);\n                }\n                return;\n            }\n            const mapAddBtn = target.closest('.map-add-button');\n            if (mapAddBtn) {\n                const mapPath = mapAddBtn.getAttribute('data-map-path') || '';\n                if (mapPath) {\n                    this.addMapItem(mapPath);\n                    this.handleFormChange('map-add', mapPath);\n                }\n                return;\n            }\n            const mapRemoveBtn = target.closest('.map-remove-button');\n            if (mapRemoveBtn) {\n                const mapPath = mapRemoveBtn.getAttribute('data-map-path') || '';\n                const itemEl = target.closest('.map-item');\n                if (mapPath && itemEl) {\n                    this.removeMapItem(mapPath, itemEl);\n                    this.handleFormChange('map-remove', mapPath);\n                }\n            }\n        });\n    }\n    switchCategory(categoryId) {\n        const sidebarItems = document.querySelectorAll('.sidebar-item');\n        sidebarItems.forEach(item => {\n            if (item.dataset.category === categoryId) {\n                item.classList.add('active');\n            }\n            else {\n                item.classList.remove('active');\n            }\n        });\n        const categories = document.querySelectorAll('.settings-category');\n        categories.forEach(category => {\n            if (category.id === `category-${categoryId}`) {\n                category.classList.remove('hidden');\n            }\n            else {\n                category.classList.add('hidden');\n            }\n        });\n    }\n    activateSidebarItem(item) {\n        document.querySelectorAll('.sidebar-item.active').forEach(el => el.classList.remove('active'));\n        item.classList.add('active');\n    }\n    scrollToSettingId(settingId) {\n        const target = document.getElementById(settingId);\n        if (!target)\n            return;\n        document.querySelectorAll('.property-item.search-target').forEach(el => el.classList.remove('search-target'));\n        target.classList.add('search-target');\n        target.scrollIntoView({ block: 'center', behavior: 'smooth' });\n        window.setTimeout(() => target.classList.remove('search-target'), 1400);\n    }\n    handleFormChange(reason, hintPath) {\n        const updated = this.buildUpdatedJson();\n        if (JSON.stringify(updated) !== JSON.stringify(this.data)) {\n            this.data = updated;\n            const rev = ++this._syncRev;\n            this._lastSentRev = rev;\n            const dirtyPaths = Array.from(this._dirtyPaths);\n            const dirtyCollections = Array.from(this._dirtyCollectionPaths);\n            const json = JSON.stringify(this.data, null, 2);\n            this._lastSentJsonText = json;\n            this._lastSentJsonTs = Date.now();\n            this.postMessage({\n                command: 'updateJson',\n                json,\n                meta: {\n                    sessionId: this._sessionId,\n                    rev,\n                    reason,\n                    hintPath,\n                    dirtyPathCount: dirtyPaths.length,\n                    dirtyCollectionCount: dirtyCollections.length,\n                    dirtyPaths: dirtyPaths.slice(0, 30),\n                    dirtyCollections: dirtyCollections.slice(0, 30),\n                    ts: Date.now()\n                }\n            });\n        }\n    }\n    scheduleFormSync() {\n        if (this._formSyncTimer !== null) {\n            window.clearTimeout(this._formSyncTimer);\n        }\n        this._formSyncTimer = window.setTimeout(() => {\n            this._formSyncTimer = null;\n            this.handleFormChange('debounced');\n        }, this._formSyncDebounceMs);\n    }\n    buildUpdatedJson() {\n        const updated = this.cloneJson(this._baseData || {});\n        for (const path of this._dirtyPaths) {\n            if (this.isUnderDirtyCollection(path))\n                continue;\n            // 注意：属性容器节点也带有 data-path，必须选择真正的表单控件（带 data-type 的 input/select/textarea），否则会读不到 value 导致“改了但不写回/不新增字段”\n            const control = document.querySelector(`input[data-path=\"${CSS.escape(path)}\"][data-type], select[data-path=\"${CSS.escape(path)}\"][data-type], textarea[data-path=\"${CSS.escape(path)}\"][data-type]`);\n            if (!control)\n                continue;\n            if (this.isControlInInvalidEditState(control)) {\n                continue;\n            }\n            const value = this.readControlValue(control);\n            if (value === undefined) {\n                this.deleteValueAtPointer(updated, path);\n            }\n            else {\n                this.setValueAtPointer(updated, path, value);\n            }\n        }\n        for (const collectionPath of this._dirtyCollectionPaths) {\n            const collected = this.collectCollectionValue(collectionPath);\n            if (collected === undefined) {\n                // collection 处于无效编辑态（例如 map key 不合法/重复），此时不落盘该 collection 的变更\n                continue;\n            }\n            if (Array.isArray(collected)) {\n                if (collected.length === 0)\n                    this.deleteValueAtPointer(updated, collectionPath);\n                else\n                    this.setValueAtPointer(updated, collectionPath, collected);\n                continue;\n            }\n            if (!collected || (typeof collected === 'object' && Object.keys(collected).length === 0)) {\n                this.deleteValueAtPointer(updated, collectionPath);\n            }\n            else {\n                this.setValueAtPointer(updated, collectionPath, collected);\n            }\n        }\n        return this.pruneEmptyObjects(updated, this._baseData);\n    }\n    isControlInInvalidEditState(control) {\n        const variant = control.closest('.anyof-variant');\n        if (variant && variant.dataset.anyofActive === 'false') {\n            return false;\n        }\n        if (control?.disabled) {\n            return false;\n        }\n        const input = control;\n        const raw = typeof input?.value === 'string' ? input.value : '';\n        const hasText = String(raw ?? '').trim().length > 0;\n        const validity = input?.validity;\n        const isValid = validity ? !!validity.valid : true;\n        return hasText && !isValid;\n    }\n    applyControlValidations(control) {\n        this.applyExclusiveMinimumValidation(control);\n        this.applyPatternValidation(control);\n    }\n    applyExclusiveMinimumValidation(control) {\n        const el = control;\n        if (!el || !el.dataset)\n            return;\n        const raw = el.dataset.exclusiveMinimum;\n        if (raw === undefined)\n            return;\n        const min = parseFloat(String(raw));\n        if (!Number.isFinite(min))\n            return;\n        const type = String(el.dataset.type || '');\n        if (type !== 'number' && type !== 'integer')\n            return;\n        const valRaw = typeof el.value === 'string' ? el.value.trim() : '';\n        if (!valRaw) {\n            try {\n                el.setCustomValidity?.('');\n            }\n            catch {\n                // ignore\n            }\n            return;\n        }\n        const num = type === 'integer' ? parseInt(valRaw, 10) : parseFloat(valRaw);\n        if (!Number.isFinite(num) || num <= min) {\n            try {\n                el.setCustomValidity?.(`Must be > ${min}`);\n            }\n            catch {\n                // ignore\n            }\n        }\n        else {\n            try {\n                el.setCustomValidity?.('');\n            }\n            catch {\n                // ignore\n            }\n        }\n    }\n    applyPatternValidation(control) {\n        const el = control;\n        if (!el || !el.dataset)\n            return;\n        const patternRaw = typeof el.dataset.pattern === 'string' ? String(el.dataset.pattern || '') : '';\n        if (!patternRaw)\n            return;\n        const type = String(el.dataset.type || '');\n        if (type !== 'string')\n            return;\n        if (!(control instanceof HTMLInputElement || control instanceof HTMLTextAreaElement))\n            return;\n        const raw = typeof control.value === 'string' ? control.value : '';\n        const shouldPreserve = String(control?.dataset?.mapRole || '') === 'value';\n        const value = shouldPreserve ? String(raw ?? '') : String(raw ?? '').trim();\n        if (!value) {\n            try {\n                control.setCustomValidity('');\n            }\n            catch {\n                // ignore\n            }\n            return;\n        }\n        try {\n            const re = new RegExp(patternRaw);\n            if (!re.test(value)) {\n                try {\n                    control.setCustomValidity(`不符合 pattern：${patternRaw}`);\n                }\n                catch {\n                    // ignore\n                }\n            }\n            else {\n                try {\n                    control.setCustomValidity('');\n                }\n                catch {\n                    // ignore\n                }\n            }\n        }\n        catch {\n            // schema 里如果给了无法编译的 pattern，避免阻塞用户编辑\n            try {\n                control.setCustomValidity('');\n            }\n            catch {\n                // ignore\n            }\n        }\n    }\n    captureFocusState() {\n        const active = document.activeElement;\n        if (!active)\n            return null;\n        const isTextInput = active instanceof HTMLInputElement || active instanceof HTMLTextAreaElement;\n        if (!isTextInput)\n            return null;\n        const selectionStart = typeof active.selectionStart === 'number' ? active.selectionStart : undefined;\n        const selectionEnd = typeof active.selectionEnd === 'number' ? active.selectionEnd : undefined;\n        if (active.classList && active.classList.contains('map-key-input')) {\n            const mapRoot = active.closest('.map-object');\n            const mapPath = mapRoot?.getAttribute('data-map-path') || '';\n            if (!mapPath)\n                return null;\n            return {\n                kind: 'mapKey',\n                mapPath,\n                key: String(active.value ?? ''),\n                selectionStart,\n                selectionEnd\n            };\n        }\n        const path = active.getAttribute && active.getAttribute('data-path');\n        const type = active.dataset ? active.dataset.type : '';\n        if (typeof path === 'string' && path && type && type !== 'boolean') {\n            return { kind: 'path', path, selectionStart, selectionEnd };\n        }\n        return null;\n    }\n    restoreFocusState(state) {\n        if (!state)\n            return;\n        const focusEl = (el) => {\n            if (!el)\n                return;\n            try {\n                el.focus?.({ preventScroll: true });\n            }\n            catch {\n                try {\n                    el.focus?.();\n                }\n                catch {\n                    // ignore\n                }\n            }\n            const start = state.selectionStart;\n            const end = state.selectionEnd;\n            if (typeof start === 'number' && typeof end === 'number') {\n                try {\n                    el.setSelectionRange?.(start, end);\n                }\n                catch {\n                    // ignore\n                }\n            }\n        };\n        if (state.kind === 'path') {\n            const selector = `input[data-path=\"${CSS.escape(state.path)}\"][data-type],` +\n                ` textarea[data-path=\"${CSS.escape(state.path)}\"][data-type],` +\n                ` select[data-path=\"${CSS.escape(state.path)}\"][data-type]`;\n            focusEl(document.querySelector(selector));\n            return;\n        }\n        if (state.kind === 'mapKey') {\n            const root = document.querySelector(`.map-object[data-map-path=\"${CSS.escape(state.mapPath)}\"]`);\n            if (!root)\n                return;\n            const inputs = Array.from(root.querySelectorAll('.map-key-input'));\n            const exact = inputs.find(i => (i.value ?? '') === state.key) || null;\n            focusEl(exact || inputs[inputs.length - 1] || null);\n        }\n    }\n    updateData(json) {\n        const focusState = this.captureFocusState();\n        try {\n            const parsed = JSON.parse(json);\n            this.data = parsed;\n            this._baseData = this.cloneJson(parsed);\n            this._dirtyPaths.clear();\n            this._dirtyCollectionPaths.clear();\n            this.debugLog('updateData: reset baseData & dirty sets', {\n                sessionId: this._sessionId,\n                topKeys: parsed && typeof parsed === 'object' ? Object.keys(parsed).slice(0, 30) : []\n            });\n            this.renderArrayObjectItemsFromData(this._baseData);\n            this.renderMapObjectItemsFromData(this._baseData);\n            this.updateFormInputs();\n            this.syncAnyOfObjectsFromData(this._baseData);\n            this.buildSearchIndex();\n            this.restoreFocusState(focusState);\n        }\n        catch (error) {\n            console.error('Failed to parse JSON:', error);\n        }\n    }\n    updateFormData(data) {\n        this.data = data;\n        this.updateFormInputs();\n        this.syncAnyOfObjectsFromData(this.data);\n    }\n    updateFormInputs() {\n        const formEditor = document.getElementById('formEditor');\n        if (!formEditor || !this.data)\n            return;\n        formEditor.querySelectorAll('input[data-path], select[data-path], textarea[data-path]').forEach(input => {\n            if (input.dataset && typeof input.dataset.const === 'string') {\n                // const 字段由 schema 固定，保持渲染时的值\n                return;\n            }\n            if (input.disabled) {\n                return;\n            }\n            const path = input.dataset.path;\n            if (!path)\n                return;\n            const value = this.getValueAtPointer(this.data, path);\n            const type = input.dataset.type;\n            if (type === 'mapKey') {\n                // map 的 key 由 map-item 渲染时写入，不随 data-path 自动回填\n                return;\n            }\n            if (type === 'boolean') {\n                // 如果 JSON 未显式设置该字段，保持 schema 默认状态（由初始 HTML 决定）\n                if (value !== undefined) {\n                    input.checked = !!value;\n                }\n                return;\n            }\n            input.value = value !== undefined ? String(value) : '';\n        });\n    }\n    cloneJson(value) {\n        return JSON.parse(JSON.stringify(value ?? {}));\n    }\n    markDirtyFromControl(control) {\n        if (control.dataset && typeof control.dataset.const === 'string') {\n            return;\n        }\n        if (control.disabled) {\n            return;\n        }\n        const path = control.dataset.path;\n        if (!path)\n            return;\n        const collectionRoot = this.getCollectionRootForControl(control);\n        if (collectionRoot) {\n            this._dirtyCollectionPaths.add(collectionRoot);\n            return;\n        }\n        const current = this.readControlValue(control);\n        const original = this.getValueAtPointer(this._baseData, path);\n        if (this.valuesEqual(current, original)) {\n            this._dirtyPaths.delete(path);\n        }\n        else {\n            this._dirtyPaths.add(path);\n        }\n    }\n    parsePointer(pointer) {\n        const raw = pointer.startsWith('/') ? pointer.slice(1) : pointer;\n        if (!raw)\n            return [];\n        return raw.split('/').map(seg => {\n            const decoded = seg.replace(/~1/g, '/').replace(/~0/g, '~');\n            if (/^\\d+$/.test(decoded)) {\n                return Number(decoded);\n            }\n            return decoded;\n        });\n    }\n    getValueAtPointer(root, pointer) {\n        const parts = this.parsePointer(pointer);\n        let cur = root;\n        for (const part of parts) {\n            if (cur === null || cur === undefined)\n                return undefined;\n            cur = cur[part];\n        }\n        return cur;\n    }\n    setValueAtPointer(root, pointer, value) {\n        const parts = this.parsePointer(pointer);\n        if (parts.length === 0)\n            return;\n        let cur = root;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            const next = parts[i + 1];\n            const shouldBeArray = typeof next === 'number';\n            if (cur[part] === undefined) {\n                cur[part] = shouldBeArray ? [] : {};\n            }\n            cur = cur[part];\n        }\n        const last = parts[parts.length - 1];\n        cur[last] = value;\n    }\n    deleteValueAtPointer(root, pointer) {\n        const parts = this.parsePointer(pointer);\n        if (parts.length === 0)\n            return;\n        let cur = root;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (cur === null || cur === undefined)\n                return;\n            cur = cur[part];\n        }\n        const last = parts[parts.length - 1];\n        if (!cur || typeof cur !== 'object')\n            return;\n        if (typeof last === 'number' && Array.isArray(cur)) {\n            cur.splice(last, 1);\n            return;\n        }\n        delete cur[last];\n    }\n    pruneEmptyObjects(node, base) {\n        if (!node || typeof node !== 'object')\n            return node;\n        if (Array.isArray(node)) {\n            return node.map((v, i) => this.pruneEmptyObjects(v, base?.[i]));\n        }\n        for (const key of Object.keys(node)) {\n            node[key] = this.pruneEmptyObjects(node[key], base?.[key]);\n            const child = node[key];\n            const baseChild = base?.[key];\n            const isEmptyObj = child && typeof child === 'object' && !Array.isArray(child) && Object.keys(child).length === 0;\n            if (isEmptyObj && (baseChild === undefined || (baseChild && typeof baseChild === 'object' && Object.keys(baseChild).length === 0))) {\n                delete node[key];\n            }\n        }\n        return node;\n    }\n    getCollectionRootForControl(control) {\n        const arrayRoot = control.closest('.array-object');\n        if (arrayRoot) {\n            const path = arrayRoot.getAttribute('data-array-path') || '';\n            return path || null;\n        }\n        const mapRoot = control.closest('.map-object');\n        if (mapRoot) {\n            const path = mapRoot.getAttribute('data-map-path') || '';\n            return path || null;\n        }\n        return null;\n    }\n    isUnderDirtyCollection(path) {\n        for (const root of this._dirtyCollectionPaths) {\n            if (path === root)\n                return true;\n            if (path.startsWith(root + '/'))\n                return true;\n        }\n        return false;\n    }\n    renderArrayObjectItemsFromData(data) {\n        const formEditor = document.getElementById('formEditor');\n        if (!formEditor)\n            return;\n        const arrays = Array.from(formEditor.querySelectorAll('.array-object'));\n        for (const arrayEl of arrays) {\n            const arrayPath = arrayEl.getAttribute('data-array-path') || '';\n            const arrayDom = arrayEl.getAttribute('data-array-dom') || '';\n            if (!arrayPath)\n                continue;\n            const itemsContainer = arrayDom\n                ? document.getElementById(`array-items-${arrayDom}`)\n                : arrayEl.querySelector('.array-items');\n            const template = arrayDom\n                ? document.getElementById(`array-template-${arrayDom}`)\n                : arrayEl.querySelector('template.array-template, template');\n            if (!itemsContainer || !template)\n                continue;\n            itemsContainer.innerHTML = '';\n            const value = this.getValueAtPointer(data, arrayPath);\n            const list = Array.isArray(value) ? value : [];\n            for (let i = 0; i < list.length; i++) {\n                const item = this.createArrayItemFromTemplate(template, arrayPath, i);\n                this.applyArrayItemExamples(arrayEl, item, arrayPath, i);\n                itemsContainer.appendChild(item);\n            }\n        }\n    }\n    renderMapObjectItemsFromData(data) {\n        const formEditor = document.getElementById('formEditor');\n        if (!formEditor)\n            return;\n        const maps = Array.from(formEditor.querySelectorAll('.map-object'));\n        for (const mapEl of maps) {\n            const mapPath = mapEl.getAttribute('data-map-path') || '';\n            const mapDom = mapEl.getAttribute('data-map-dom') || '';\n            if (!mapPath || !mapDom)\n                continue;\n            const itemsContainer = document.getElementById(`map-items-${mapDom}`);\n            const template = document.getElementById(`map-template-${mapDom}`);\n            if (!itemsContainer || !template)\n                continue;\n            itemsContainer.innerHTML = '';\n            const value = this.getValueAtPointer(data, mapPath);\n            const obj = value && typeof value === 'object' && !Array.isArray(value) ? value : {};\n            const keys = Object.keys(obj).sort((a, b) => a.localeCompare(b));\n            for (const k of keys) {\n                const item = this.createMapItemFromTemplate(template, mapEl, mapPath, k);\n                itemsContainer.appendChild(item);\n            }\n        }\n    }\n    addArrayItem(arrayPath) {\n        const formEditor = document.getElementById('formEditor');\n        if (!formEditor)\n            return;\n        const arrayEl = formEditor.querySelector(`.array-object[data-array-path=\"${CSS.escape(arrayPath)}\"]`);\n        if (!arrayEl)\n            return;\n        const arrayDom = arrayEl.getAttribute('data-array-dom') || '';\n        const itemsContainer = arrayDom\n            ? document.getElementById(`array-items-${arrayDom}`)\n            : arrayEl.querySelector('.array-items');\n        const template = arrayDom\n            ? document.getElementById(`array-template-${arrayDom}`)\n            : arrayEl.querySelector('template.array-template, template');\n        if (!itemsContainer || !template)\n            return;\n        const index = itemsContainer.querySelectorAll('.array-item').length;\n        const item = this.createArrayItemFromTemplate(template, arrayPath, index);\n        this.applyArrayItemExamples(arrayEl, item, arrayPath, index);\n        itemsContainer.appendChild(item);\n        this._dirtyCollectionPaths.add(arrayPath);\n        const firstControl = item.querySelector('[data-path]');\n        if (firstControl && 'focus' in firstControl) {\n            firstControl.focus();\n        }\n    }\n    addMapItem(mapPath) {\n        const formEditor = document.getElementById('formEditor');\n        if (!formEditor)\n            return;\n        const mapEl = formEditor.querySelector(`.map-object[data-map-path=\"${CSS.escape(mapPath)}\"]`);\n        if (!mapEl)\n            return;\n        const mapDom = mapEl.getAttribute('data-map-dom') || '';\n        const itemsContainer = document.getElementById(`map-items-${mapDom}`);\n        const template = document.getElementById(`map-template-${mapDom}`);\n        if (!itemsContainer || !template)\n            return;\n        const item = this.createMapItemFromTemplate(template, mapEl, mapPath, '');\n        itemsContainer.appendChild(item);\n        this._dirtyCollectionPaths.add(mapPath);\n        const keyInput = item.querySelector('.map-key-input');\n        if (keyInput)\n            keyInput.focus();\n    }\n    removeMapItem(mapPath, itemEl) {\n        itemEl.remove();\n        this._dirtyCollectionPaths.add(mapPath);\n        this.validateMapObject(mapPath);\n    }\n    removeArrayItem(arrayPath, itemEl) {\n        itemEl.remove();\n        this.reindexArrayItems(arrayPath);\n        this._dirtyCollectionPaths.add(arrayPath);\n    }\n    reindexArrayItems(arrayPath) {\n        const formEditor = document.getElementById('formEditor');\n        if (!formEditor)\n            return;\n        const arrayEl = formEditor.querySelector(`.array-object[data-array-path=\"${CSS.escape(arrayPath)}\"]`);\n        if (!arrayEl)\n            return;\n        const arrayDom = arrayEl.getAttribute('data-array-dom') || '';\n        const itemsContainer = arrayDom\n            ? document.getElementById(`array-items-${arrayDom}`)\n            : arrayEl.querySelector('.array-items');\n        if (!itemsContainer)\n            return;\n        const items = Array.from(itemsContainer.querySelectorAll('.array-item'));\n        const basePrefix = arrayPath.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        items.forEach((item, newIndex) => {\n            item.setAttribute('data-array-index', String(newIndex));\n            const titleEl = item.querySelector('.array-item-title');\n            if (titleEl) {\n                titleEl.textContent = `Item ${newIndex}`;\n            }\n            const controls = Array.from(item.querySelectorAll('[data-path]'));\n            for (const c of controls) {\n                const p = c.getAttribute('data-path') || '';\n                if (!p)\n                    continue;\n                // 把 `${arrayPath}/<oldIndex>` 段替换成 `${arrayPath}/${newIndex}`\n                const updated = p.replace(new RegExp(`^${basePrefix}\\\\/\\\\d+(?=\\\\/|$)`), `${arrayPath}/${newIndex}`);\n                c.setAttribute('data-path', updated);\n            }\n            const anyOfRoots = Array.from(item.querySelectorAll('[data-anyof-path]'));\n            for (const el of anyOfRoots) {\n                const p = el.getAttribute('data-anyof-path') || '';\n                if (!p)\n                    continue;\n                const updated = p.replace(new RegExp(`^${basePrefix}\\\\/\\\\d+(?=\\\\/|$)`), `${arrayPath}/${newIndex}`);\n                el.setAttribute('data-anyof-path', updated);\n            }\n            this.applyArrayItemExamples(arrayEl, item, arrayPath, newIndex);\n            this.applyPlaceholderExamples(item);\n        });\n    }\n    createArrayItemFromTemplate(template, arrayPath, index) {\n        const clone = template.content.cloneNode(true);\n        const wrapper = document.createElement('div');\n        wrapper.appendChild(clone);\n        const item = wrapper.querySelector('.array-item');\n        // 替换 __INDEX__\n        item.setAttribute('data-array-index', String(index));\n        const titleEl = item.querySelector('.array-item-title');\n        if (titleEl) {\n            titleEl.textContent = `Item ${index}`;\n        }\n        const keySeg = (() => {\n            const parts = String(arrayPath || '').split('/').filter(Boolean);\n            return parts.length > 0 ? parts[parts.length - 1] : '';\n        })();\n        const controls = Array.from(item.querySelectorAll('[data-path]'));\n        for (const c of controls) {\n            const p = c.getAttribute('data-path') || '';\n            let updated = p.replace(/__INDEX__/g, String(index));\n            if (keySeg) {\n                updated = updated.replace(/\\/__KEY__(?=\\/|$)/g, `/${keySeg}`);\n            }\n            c.setAttribute('data-path', updated);\n        }\n        const anyOfRoots = Array.from(item.querySelectorAll('[data-anyof-path]'));\n        for (const el of anyOfRoots) {\n            const p = el.getAttribute('data-anyof-path') || '';\n            let updated = p.replace(/__INDEX__/g, String(index));\n            if (keySeg) {\n                updated = updated.replace(/\\/__KEY__(?=\\/|$)/g, `/${keySeg}`);\n            }\n            el.setAttribute('data-anyof-path', updated);\n        }\n        const removeBtn = item.querySelector('.array-remove-button');\n        if (removeBtn) {\n            removeBtn.setAttribute('data-array-path', arrayPath);\n        }\n        this.applyPlaceholderExamples(item);\n        return item;\n    }\n    safeParseJson(value) {\n        if (!value)\n            return undefined;\n        try {\n            return JSON.parse(value);\n        }\n        catch {\n            return undefined;\n        }\n    }\n    applyPlaceholderExamples(rootEl) {\n        const controls = Array.from(rootEl.querySelectorAll('[data-placeholder-examples]'));\n        for (const c of controls) {\n            if (!(c instanceof HTMLInputElement || c instanceof HTMLTextAreaElement))\n                continue;\n            const raw = c.getAttribute('data-placeholder-examples');\n            const examples = this.safeParseJson(raw);\n            if (!Array.isArray(examples) || examples.length === 0)\n                continue;\n            // 若用户已有输入值，则不要覆盖（placeholder 无意义且会干扰视觉）\n            if (typeof c.value === 'string' && c.value.length > 0)\n                continue;\n            const cached = (() => {\n                const v = String(c?.dataset?.placeholderExampleIndex || '').trim();\n                if (!v)\n                    return null;\n                const n = parseInt(v, 10);\n                return Number.isFinite(n) && n >= 0 && n < examples.length ? n : null;\n            })();\n            const idx = cached ?? Math.floor(Math.random() * examples.length);\n            c.dataset.placeholderExampleIndex = String(idx);\n            const example = examples[idx];\n            if (example === undefined || example === null)\n                continue;\n            if (typeof example === 'string' || typeof example === 'number') {\n                c.placeholder = String(example);\n            }\n            else if (typeof example === 'boolean') {\n                // boolean 没有 placeholder\n            }\n            else {\n                c.placeholder = JSON.stringify(example);\n            }\n        }\n    }\n    applyArrayItemExamples(arrayEl, itemEl, arrayPath, index) {\n        const examplesRaw = arrayEl.getAttribute('data-array-examples');\n        const examples = this.safeParseJson(examplesRaw);\n        if (!Array.isArray(examples) || examples.length === 0)\n            return;\n        const cached = (() => {\n            const v = String(itemEl.dataset.arrayExampleIndex || '').trim();\n            if (!v)\n                return null;\n            const n = parseInt(v, 10);\n            return Number.isFinite(n) && n >= 0 && n < examples.length ? n : null;\n        })();\n        const exampleIndex = cached ?? Math.floor(Math.random() * examples.length);\n        itemEl.dataset.arrayExampleIndex = String(exampleIndex);\n        const example = examples[exampleIndex];\n        if (example === undefined || example === null)\n            return;\n        // scalar item: 控件直接绑定到 `${arrayPath}/${index}`\n        const direct = itemEl.querySelector(`[data-path=\"${CSS.escape(arrayPath + '/' + String(index))}\"][data-type]`);\n        if (direct && (direct instanceof HTMLInputElement || direct instanceof HTMLTextAreaElement)) {\n            if (typeof example === 'string' || typeof example === 'number') {\n                direct.placeholder = String(example);\n            }\n            else if (typeof example === 'boolean') {\n                // boolean 没有 placeholder\n            }\n            else {\n                direct.placeholder = JSON.stringify(example);\n            }\n            return;\n        }\n        // object item: 逐字段设置 placeholder（仅对 input/textarea 生效）\n        if (example && typeof example === 'object' && !Array.isArray(example)) {\n            const controls = Array.from(itemEl.querySelectorAll('[data-path][data-type]'));\n            const prefix = `${arrayPath}/${index}/`;\n            for (const c of controls) {\n                const p = c.getAttribute('data-path') || '';\n                if (!p.startsWith(prefix))\n                    continue;\n                const rest = p.slice(prefix.length);\n                // 只处理对象的“直接子属性”，更深层级交给 schema 自身的 placeholder\n                if (!rest || rest.includes('/'))\n                    continue;\n                const keySeg = rest.replace(/~1/g, '/').replace(/~0/g, '~');\n                const v = example[keySeg];\n                if (v === undefined || v === null)\n                    continue;\n                if (c instanceof HTMLInputElement || c instanceof HTMLTextAreaElement) {\n                    if (typeof v === 'string' || typeof v === 'number')\n                        c.placeholder = String(v);\n                    else\n                        c.placeholder = JSON.stringify(v);\n                }\n            }\n        }\n    }\n    encodeJsonPointerSegment(seg) {\n        return String(seg).replace(/~/g, '~0').replace(/\\//g, '~1');\n    }\n    createMapItemFromTemplate(template, mapEl, mapPath, key) {\n        const clone = template.content.cloneNode(true);\n        const wrapper = document.createElement('div');\n        wrapper.appendChild(clone);\n        const item = wrapper.querySelector('.map-item');\n        const keyInput = item.querySelector('.map-key-input');\n        const keyPattern = mapEl.getAttribute('data-map-key-pattern') || '';\n        if (keyInput) {\n            keyInput.value = key || '';\n            if (keyPattern) {\n                try {\n                    keyInput.pattern = keyPattern;\n                }\n                catch {\n                    // ignore invalid HTML pattern\n                }\n                keyInput.title = `Key must match: ${keyPattern}`;\n            }\n        }\n        // Track what segment is currently baked into data-path attributes for this item.\n        // Newly cloned templates still use \"__KEY__\".\n        item.dataset.mapKeySeg = '__KEY__';\n        const removeBtn = item.querySelector('.map-remove-button');\n        if (removeBtn) {\n            removeBtn.setAttribute('data-map-path', mapPath);\n        }\n        this.rebindMapItem(mapPath, item);\n        return item;\n    }\n    rebindMapItem(mapPath, itemEl) {\n        const keyInput = itemEl.querySelector('.map-key-input');\n        if (!keyInput)\n            return;\n        const rawKey = (keyInput.value ?? '').trim();\n        const prevSeg = String(itemEl.dataset.mapKeySeg || '__KEY__');\n        // Update all bound paths under this map item (scalar value OR object value fields).\n        if (rawKey) {\n            const newSeg = this.encodeJsonPointerSegment(rawKey);\n            const oldPrefix = `${mapPath}/${prevSeg}`;\n            const placeholderPrefix = `${mapPath}/__KEY__`;\n            const bound = Array.from(itemEl.querySelectorAll('[data-path]'));\n            for (const el of bound) {\n                const t = el?.dataset?.type;\n                if (t === 'mapKey')\n                    continue;\n                const p = el.getAttribute('data-path') || '';\n                if (!p)\n                    continue;\n                let updated = p;\n                if (updated.startsWith(oldPrefix)) {\n                    updated = `${mapPath}/${newSeg}${updated.slice(oldPrefix.length)}`;\n                }\n                else if (updated.startsWith(placeholderPrefix)) {\n                    updated = `${mapPath}/${newSeg}${updated.slice(placeholderPrefix.length)}`;\n                }\n                if (updated !== p) {\n                    el.setAttribute('data-path', updated);\n                }\n            }\n            const boundArrayPaths = Array.from(itemEl.querySelectorAll('[data-array-path]'));\n            for (const el of boundArrayPaths) {\n                const p = el.getAttribute('data-array-path') || '';\n                if (!p)\n                    continue;\n                let updated = p;\n                if (updated.startsWith(oldPrefix)) {\n                    updated = `${mapPath}/${newSeg}${updated.slice(oldPrefix.length)}`;\n                }\n                else if (updated.startsWith(placeholderPrefix)) {\n                    updated = `${mapPath}/${newSeg}${updated.slice(placeholderPrefix.length)}`;\n                }\n                if (updated !== p) {\n                    el.setAttribute('data-array-path', updated);\n                }\n            }\n            const anyOfRoots = Array.from(itemEl.querySelectorAll('[data-anyof-path]'));\n            for (const el of anyOfRoots) {\n                const p = el.getAttribute('data-anyof-path') || '';\n                if (!p)\n                    continue;\n                let updated = p;\n                if (updated.startsWith(oldPrefix)) {\n                    updated = `${mapPath}/${newSeg}${updated.slice(oldPrefix.length)}`;\n                }\n                else if (updated.startsWith(placeholderPrefix)) {\n                    updated = `${mapPath}/${newSeg}${updated.slice(placeholderPrefix.length)}`;\n                }\n                if (updated !== p) {\n                    el.setAttribute('data-anyof-path', updated);\n                }\n            }\n            itemEl.dataset.mapKeySeg = newSeg;\n        }\n        // Enable/disable value controls when key is empty; keep const fields read-only.\n        // Also disable nested buttons/selectors to prevent creating items under \"__KEY__\".\n        // NOTE: map 的标量值可能渲染在 header（紧凑布局），所以这里要覆盖整个 item。\n        const interactives = Array.from(itemEl.querySelectorAll('input, select, textarea, button'));\n        for (const el of interactives) {\n            if (el.classList.contains('map-key-input'))\n                continue;\n            if (el.classList.contains('map-remove-button'))\n                continue;\n            const isConst = typeof el?.dataset?.const === 'string';\n            const variant = el.closest('.anyof-variant');\n            const isInactiveVariant = !!(variant && variant.dataset.anyofActive === 'false');\n            if (!rawKey) {\n                el.disabled = true;\n                continue;\n            }\n            if (isInactiveVariant) {\n                el.disabled = true;\n                continue;\n            }\n            if (isConst) {\n                el.disabled = true;\n                continue;\n            }\n            el.disabled = false;\n        }\n    }\n    validateMapObject(mapPath) {\n        const formEditor = document.getElementById('formEditor');\n        if (!formEditor)\n            return true;\n        const mapEl = formEditor.querySelector(`.map-object[data-map-path=\"${CSS.escape(mapPath)}\"]`);\n        if (!mapEl)\n            return true;\n        const patternRaw = mapEl.getAttribute('data-map-key-pattern') || '';\n        const pattern = (() => {\n            const p = String(patternRaw || '');\n            if (!p)\n                return null;\n            try {\n                if (p.startsWith('^') && p.endsWith('$'))\n                    return new RegExp(p);\n                return new RegExp(`^(?:${p})$`);\n            }\n            catch {\n                return null;\n            }\n        })();\n        const keys = new Map();\n        const items = Array.from(mapEl.querySelectorAll('.map-item'));\n        let ok = true;\n        for (const item of items) {\n            const keyInput = item.querySelector('.map-key-input');\n            if (!keyInput)\n                continue;\n            const k = (keyInput.value ?? '').trim();\n            keyInput.setCustomValidity('');\n            keyInput.classList.remove('map-key-invalid');\n            if (!k) {\n                // 新增行未填写 key：不算错误，但也不会被写入\n                continue;\n            }\n            if (pattern && !pattern.test(k)) {\n                ok = false;\n                keyInput.setCustomValidity(`Key must match: ${patternRaw}`);\n                keyInput.classList.add('map-key-invalid');\n                continue;\n            }\n            const count = keys.get(k) || 0;\n            keys.set(k, count + 1);\n        }\n        for (const item of items) {\n            const keyInput = item.querySelector('.map-key-input');\n            if (!keyInput)\n                continue;\n            const k = (keyInput.value ?? '').trim();\n            if (!k)\n                continue;\n            if ((keys.get(k) || 0) > 1) {\n                ok = false;\n                keyInput.setCustomValidity('Duplicate key');\n                keyInput.classList.add('map-key-invalid');\n            }\n        }\n        return ok;\n    }\n    syncAnyOfObjectsFromData(data) {\n        const formEditor = document.getElementById('formEditor');\n        if (!formEditor)\n            return;\n        const roots = Array.from(formEditor.querySelectorAll('.anyof-object'));\n        for (const root of roots) {\n            const path = root.getAttribute('data-anyof-path') || '';\n            const selector = root.querySelector('.anyof-selector');\n            if (!path || !selector)\n                continue;\n            const value = this.getValueAtPointer(data, path);\n            if (value && typeof value === 'object' && !Array.isArray(value)) {\n                const variants = Array.from(root.querySelectorAll('.anyof-variant'));\n                for (const v of variants) {\n                    const k = v.getAttribute('data-anyof-discriminator-key') || '';\n                    const c = v.getAttribute('data-anyof-discriminator-const') || '';\n                    const idx = v.getAttribute('data-anyof-index') || '';\n                    if (!k || !c || !idx)\n                        continue;\n                    if (value[k] === c) {\n                        selector.value = idx;\n                        break;\n                    }\n                }\n            }\n            this.applyAnyOfObjectSelection(root);\n        }\n    }\n    applyAnyOfObjectSelection(anyOfRoot) {\n        const selector = anyOfRoot.querySelector('.anyof-selector');\n        if (!selector)\n            return;\n        const activeIndex = String(selector.value || '0');\n        const variants = Array.from(anyOfRoot.querySelectorAll('.anyof-variant'));\n        for (const v of variants) {\n            const idx = v.getAttribute('data-anyof-index') || '';\n            const active = idx === activeIndex;\n            v.dataset.anyofActive = active ? 'true' : 'false';\n            v.classList.toggle('hidden', !active);\n            v.classList.toggle('active', active);\n            const controls = Array.from(v.querySelectorAll('[data-type]'));\n            for (const c of controls) {\n                const isConst = typeof c?.dataset?.const === 'string';\n                const shouldDisableByMapKey = (() => {\n                    const mapItem = c.closest('.map-item');\n                    if (!mapItem)\n                        return false;\n                    const keyInput = mapItem.querySelector('.map-key-input');\n                    if (!keyInput)\n                        return false;\n                    return (keyInput.value ?? '').trim().length === 0;\n                })();\n                if (!active) {\n                    c.disabled = true;\n                    continue;\n                }\n                if (isConst) {\n                    c.disabled = true;\n                    continue;\n                }\n                c.disabled = shouldDisableByMapKey;\n            }\n        }\n    }\n    handleAnyOfSelectorChange(selector) {\n        const root = selector.closest('.anyof-object');\n        if (!root)\n            return;\n        this.applyAnyOfObjectSelection(root);\n        const collectionRoot = this.getCollectionRootForControl(selector);\n        if (collectionRoot) {\n            this._dirtyCollectionPaths.add(collectionRoot);\n            this.handleFormChange('anyof-change', collectionRoot);\n            return;\n        }\n        const controls = Array.from(root.querySelectorAll('[data-path][data-type]'));\n        for (const c of controls) {\n            const p = c.getAttribute('data-path') || '';\n            if (!p)\n                continue;\n            this._dirtyPaths.add(p);\n        }\n        this.handleFormChange('anyof-change', root.getAttribute('data-anyof-path') || '');\n    }\n    collectCollectionValue(path) {\n        const formEditor = document.getElementById('formEditor');\n        if (!formEditor)\n            return [];\n        const arrayEl = formEditor.querySelector(`.array-object[data-array-path=\"${CSS.escape(path)}\"]`);\n        if (arrayEl) {\n            return this.collectArrayObjectValue(path);\n        }\n        const mapEl = formEditor.querySelector(`.map-object[data-map-path=\"${CSS.escape(path)}\"]`);\n        if (mapEl) {\n            return this.collectMapObjectValue(path);\n        }\n        return [];\n    }\n    collectArrayObjectValue(arrayPath) {\n        const formEditor = document.getElementById('formEditor');\n        if (!formEditor)\n            return [];\n        const arrayEl = formEditor.querySelector(`.array-object[data-array-path=\"${CSS.escape(arrayPath)}\"]`);\n        if (!arrayEl)\n            return [];\n        const arrayDom = arrayEl.getAttribute('data-array-dom') || '';\n        const itemsContainer = arrayDom\n            ? document.getElementById(`array-items-${arrayDom}`)\n            : arrayEl.querySelector('.array-items');\n        if (!itemsContainer)\n            return [];\n        const items = Array.from(itemsContainer.querySelectorAll('.array-item'));\n        const result = [];\n        for (const itemEl of items) {\n            const indexStr = itemEl.getAttribute('data-array-index') || '0';\n            const index = parseInt(indexStr, 10);\n            const prefix = `${arrayPath}/${index}`;\n            // scalar array: 单控件直接绑定到 `${arrayPath}/${index}`\n            const direct = itemEl.querySelector(`[data-path=\"${CSS.escape(prefix)}\"][data-type]`);\n            if (direct) {\n                if (this.isControlInInvalidEditState(direct)) {\n                    return undefined;\n                }\n                const v = this.readControlValue(direct);\n                if (v !== undefined) {\n                    result.push(v);\n                }\n                continue;\n            }\n            // object array: 多控件以 `${arrayPath}/${index}/...` 方式绑定\n            const obj = {};\n            const controls = Array.from(itemEl.querySelectorAll('[data-path]'));\n            for (const c of controls) {\n                const p = c.getAttribute('data-path') || '';\n                if (!p.startsWith(prefix + '/'))\n                    continue;\n                if (this.isControlInInvalidEditState(c)) {\n                    return undefined;\n                }\n                const rel = p.slice(prefix.length);\n                const value = this.readControlValue(c);\n                if (value === undefined)\n                    continue;\n                this.setValueAtPointer(obj, rel, value);\n            }\n            if (obj && typeof obj === 'object' && Object.keys(obj).length > 0) {\n                result.push(obj);\n            }\n        }\n        return result;\n    }\n    collectMapObjectValue(mapPath) {\n        const formEditor = document.getElementById('formEditor');\n        if (!formEditor)\n            return {};\n        const mapEl = formEditor.querySelector(`.map-object[data-map-path=\"${CSS.escape(mapPath)}\"]`);\n        if (!mapEl)\n            return {};\n        if (!this.validateMapObject(mapPath)) {\n            // map key 不合法/重复：跳过写回，避免把临时无效输入写入源 JSON\n            return undefined;\n        }\n        const mapDom = mapEl.getAttribute('data-map-dom') || '';\n        const itemsContainer = document.getElementById(`map-items-${mapDom}`);\n        if (!itemsContainer)\n            return {};\n        const items = Array.from(itemsContainer.querySelectorAll('.map-item'));\n        const result = {};\n        for (const item of items) {\n            const keyInput = item.querySelector('.map-key-input');\n            if (!keyInput)\n                continue;\n            const key = (keyInput.value ?? '').trim();\n            if (!key)\n                continue;\n            const keySeg = this.encodeJsonPointerSegment(key);\n            const valuePrefix = `${mapPath}/${keySeg}`;\n            // Scalar map value: single control bound to `${mapPath}/${keySeg}`\n            const scalar = item.querySelector(`[data-map-role=\"value\"][data-path=\"${CSS.escape(valuePrefix)}\"][data-type]`);\n            if (scalar) {\n                if (this.isControlInInvalidEditState(scalar)) {\n                    return undefined;\n                }\n                const parsed = this.readControlValue(scalar);\n                if (parsed === undefined)\n                    continue;\n                result[key] = parsed;\n                continue;\n            }\n            // Array map value: nested array-object bound to `${mapPath}/${keySeg}`\n            const nestedArray = item.querySelector(`.array-object[data-array-path=\"${CSS.escape(valuePrefix)}\"]`);\n            if (nestedArray) {\n                const collected = this.collectArrayObjectValue(valuePrefix);\n                if (collected === undefined) {\n                    return undefined;\n                }\n                if (Array.isArray(collected) && collected.length > 0) {\n                    result[key] = collected;\n                }\n                continue;\n            }\n            // Object map value: multiple controls bound under `${mapPath}/${keySeg}/...`\n            const obj = {};\n            const controls = Array.from(item.querySelectorAll('[data-path][data-type]'));\n            for (const c of controls) {\n                const p = c.getAttribute('data-path') || '';\n                if (!p.startsWith(valuePrefix + '/'))\n                    continue;\n                if (this.isControlInInvalidEditState(c)) {\n                    return undefined;\n                }\n                const value = this.readControlValue(c);\n                if (value === undefined)\n                    continue;\n                const rel = p.slice(valuePrefix.length);\n                this.setValueAtPointer(obj, rel, value);\n            }\n            if (obj && typeof obj === 'object' && Object.keys(obj).length > 0) {\n                result[key] = obj;\n            }\n        }\n        return result;\n    }\n    readControlValue(control) {\n        const variant = control.closest('.anyof-variant');\n        if (variant && variant.dataset.anyofActive === 'false') {\n            return undefined;\n        }\n        const constRaw = control?.dataset?.const;\n        if (typeof constRaw === 'string') {\n            try {\n                return JSON.parse(constRaw);\n            }\n            catch {\n                return constRaw;\n            }\n        }\n        if (control?.disabled) {\n            return undefined;\n        }\n        const type = control.dataset.type;\n        if (type === 'boolean') {\n            return control.checked;\n        }\n        const raw = control.value;\n        // Map string values should preserve empty string (e.g. env vars allow \"\").\n        if ((type === 'string' || type === 'enum') && control?.dataset?.mapRole === 'value') {\n            return String(raw ?? '');\n        }\n        const str = (raw ?? '').trim();\n        if (type === 'number' || type === 'integer') {\n            if (!str)\n                return undefined;\n            const num = type === 'integer' ? parseInt(str, 10) : parseFloat(str);\n            return Number.isFinite(num) ? num : undefined;\n        }\n        if (type === 'array') {\n            if (!str)\n                return undefined;\n            const parts = str.split(',').map(s => s.trim()).filter(Boolean);\n            return parts.length > 0 ? parts : undefined;\n        }\n        // string / enum / 其他输入：空值表示“未设置”\n        return str ? str : undefined;\n    }\n    safeParseJsonText(text) {\n        if (typeof text !== 'string' || text.trim().length === 0)\n            return undefined;\n        try {\n            return JSON.parse(text);\n        }\n        catch {\n            return undefined;\n        }\n    }\n    deepEqualJson(a, b) {\n        if (a === b)\n            return true;\n        if (a === null || b === null)\n            return a === b;\n        if (typeof a !== typeof b)\n            return false;\n        if (Array.isArray(a) || Array.isArray(b)) {\n            if (!Array.isArray(a) || !Array.isArray(b))\n                return false;\n            if (a.length !== b.length)\n                return false;\n            for (let i = 0; i < a.length; i++) {\n                if (!this.deepEqualJson(a[i], b[i]))\n                    return false;\n            }\n            return true;\n        }\n        if (typeof a === 'object' && typeof b === 'object') {\n            const aKeys = Object.keys(a).sort();\n            const bKeys = Object.keys(b).sort();\n            if (aKeys.length !== bKeys.length)\n                return false;\n            for (let i = 0; i < aKeys.length; i++) {\n                if (aKeys[i] !== bKeys[i])\n                    return false;\n                const k = aKeys[i];\n                if (!this.deepEqualJson(a[k], b[k]))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    valuesEqual(a, b) {\n        if (a === undefined && b === undefined)\n            return true;\n        if (a === undefined && b === null)\n            return false;\n        if (a === null && b === undefined)\n            return false;\n        if (Array.isArray(a) || Array.isArray(b)) {\n            if (!Array.isArray(a) || !Array.isArray(b))\n                return false;\n            if (a.length !== b.length)\n                return false;\n            for (let i = 0; i < a.length; i++) {\n                if (a[i] !== b[i])\n                    return false;\n            }\n            return true;\n        }\n        return a === b;\n    }\n    normalizeText(value) {\n        return (value || '').toLowerCase().trim();\n    }\n    getSearchQuery() {\n        const raw = (this._searchField && typeof this._searchField.value === 'string') ? this._searchField.value : '';\n        return String(raw || '');\n    }\n    maybeShowSearchResults() {\n        const query = this.getSearchQuery().trim();\n        if (query.length === 0)\n            return;\n        this.showSearchResults();\n    }\n    handleSearchInput() {\n        const query = this.getSearchQuery().trim();\n        if (!this._searchResultsEl)\n            return;\n        if (query.length === 0) {\n            this._searchResults = [];\n            this._searchSelectedIndex = -1;\n            this.hideSearchResults();\n            return;\n        }\n        this._searchResults = this.searchSettings(query);\n        this._searchSelectedIndex = this._searchResults.length > 0 ? 0 : -1;\n        this.renderSearchResults(query);\n        this.showSearchResults();\n    }\n    handleSearchKeydown(e) {\n        if (!this._searchResultsEl)\n            return;\n        if (e.key === 'Escape') {\n            e.preventDefault();\n            if (!this._searchResultsEl.classList.contains('hidden')) {\n                this.hideSearchResults();\n            }\n            else if (this._searchField) {\n                this._searchField.value = '';\n                this.handleSearchInput();\n            }\n            return;\n        }\n        if (this._searchResults.length === 0)\n            return;\n        if (e.key === 'ArrowDown') {\n            e.preventDefault();\n            this._searchSelectedIndex = Math.min(this._searchSelectedIndex + 1, this._searchResults.length - 1);\n            this.updateSearchActiveItem();\n            return;\n        }\n        if (e.key === 'ArrowUp') {\n            e.preventDefault();\n            this._searchSelectedIndex = Math.max(this._searchSelectedIndex - 1, 0);\n            this.updateSearchActiveItem();\n            return;\n        }\n        if (e.key === 'Enter') {\n            e.preventDefault();\n            const item = this._searchResults[this._searchSelectedIndex];\n            if (item) {\n                this.navigateToSetting(item);\n            }\n            return;\n        }\n    }\n    showSearchResults() {\n        if (!this._searchResultsEl)\n            return;\n        if (this._searchResultsEl.innerHTML.trim().length === 0)\n            return;\n        this._searchResultsEl.classList.remove('hidden');\n    }\n    hideSearchResults() {\n        if (!this._searchResultsEl)\n            return;\n        this._searchResultsEl.classList.add('hidden');\n    }\n    buildSearchIndex() {\n        this._searchIndex = [];\n        const topLevelTargets = new Map();\n        const items = Array.from(document.querySelectorAll('.property-item'));\n        for (const el of items) {\n            const key = el.getAttribute('data-property') || '';\n            const propertyDomId = el.getAttribute('data-property-dom') || '';\n            const categoryDomId = el.getAttribute('data-category') || '';\n            const titleEl = el.querySelector('.property-title');\n            const descEl = el.querySelector('.property-description');\n            const title = (titleEl?.innerText || '').replace(/\\*/g, '').trim();\n            const description = (descEl?.innerText || '').trim();\n            const topLevel = el.closest('.property-item.depth-0');\n            const topLevelTitleEl = topLevel?.querySelector('.property-title');\n            const categoryTitle = (topLevelTitleEl?.innerText || '').replace(/\\*/g, '').trim();\n            if (!key || !propertyDomId)\n                continue;\n            // 仅对顶层 key 建立映射，供 schema 扩展索引使用\n            if (topLevel && topLevel === el) {\n                topLevelTargets.set(key, { propertyDomId, categoryDomId, categoryTitle });\n            }\n            this._searchIndex.push({\n                key,\n                title: title || key,\n                description,\n                categoryDomId,\n                categoryTitle,\n                propertyDomId\n            });\n        }\n        this.extendSearchIndexFromSchema(topLevelTargets);\n    }\n    extendSearchIndexFromSchema(topLevelTargets) {\n        if (!this.schema || typeof this.schema !== 'object')\n            return;\n        const root = this.schema;\n        const rootProps = root.properties;\n        if (!rootProps)\n            return;\n        const maxDepth = 6;\n        const maxExtraItems = 1500;\n        let added = 0;\n        const seenKeys = new Set(this._searchIndex.map(i => `${i.propertyDomId}::${i.key}`));\n        const visitedRefs = new Set();\n        const visitedObjects = new WeakSet();\n        const resolveInternalRef = (ref) => {\n            if (!ref.startsWith('#/'))\n                return undefined;\n            const parts = ref\n                .slice(2)\n                .split('/')\n                .map(p => p.replace(/~1/g, '/').replace(/~0/g, '~'));\n            let cur = root;\n            for (const p of parts) {\n                cur = cur?.[p];\n            }\n            return cur;\n        };\n        const getRefName = (ref) => {\n            const m = ref.match(/#\\/(?:\\$defs|definitions)\\/([^/]+)$/);\n            return m ? m[1] : ref;\n        };\n        const formatPath = (parts) => {\n            let out = '';\n            for (const p of parts) {\n                if (!out) {\n                    out = p;\n                    continue;\n                }\n                if (p === '[]') {\n                    out += '[]';\n                }\n                else {\n                    out += `.${p}`;\n                }\n            }\n            return out;\n        };\n        const addItem = (target, key, title, description) => {\n            if (added >= maxExtraItems)\n                return;\n            const deDupeKey = `${target.propertyDomId}::${key}`;\n            if (seenKeys.has(deDupeKey))\n                return;\n            seenKeys.add(deDupeKey);\n            added += 1;\n            this._searchIndex.push({\n                key,\n                title,\n                description,\n                categoryDomId: target.categoryDomId,\n                categoryTitle: target.categoryTitle,\n                propertyDomId: target.propertyDomId\n            });\n        };\n        const walk = (node, pathParts, target, depth) => {\n            if (!node || typeof node !== 'object')\n                return;\n            if (depth > maxDepth)\n                return;\n            if (visitedObjects.has(node))\n                return;\n            visitedObjects.add(node);\n            // follow internal $ref\n            if (typeof node.$ref === 'string' && node.$ref.startsWith('#/')) {\n                const ref = node.$ref;\n                const refName = getRefName(ref);\n                const refKey = `${formatPath(pathParts)} • ${refName}`;\n                const resolved = resolveInternalRef(ref);\n                const desc = (resolved && typeof resolved === 'object' && typeof resolved.description === 'string') ? resolved.description : '';\n                addItem(target, refKey, refName, desc);\n                if (visitedRefs.has(ref))\n                    return;\n                visitedRefs.add(ref);\n                if (resolved) {\n                    walk(resolved, pathParts, target, depth + 1);\n                }\n                return;\n            }\n            const variants = []\n                .concat(Array.isArray(node.anyOf) ? node.anyOf : [])\n                .concat(Array.isArray(node.oneOf) ? node.oneOf : [])\n                .concat(Array.isArray(node.allOf) ? node.allOf : []);\n            for (const v of variants) {\n                walk(v, pathParts, target, depth + 1);\n            }\n            // object properties\n            const props = node.properties;\n            if (props && typeof props === 'object') {\n                for (const [propName, propSchema] of Object.entries(props)) {\n                    const nextPath = pathParts.concat(propName);\n                    const title = (propSchema && typeof propSchema.title === 'string') ? propSchema.title : propName;\n                    const desc = (propSchema && typeof propSchema.description === 'string') ? propSchema.description : '';\n                    addItem(target, formatPath(nextPath), title, desc);\n                    walk(propSchema, nextPath, target, depth + 1);\n                }\n            }\n            // array items\n            const items = node.items;\n            if (items) {\n                walk(items, pathParts.concat('[]'), target, depth + 1);\n            }\n        };\n        for (const [topKey, topSchema] of Object.entries(rootProps)) {\n            const target = topLevelTargets.get(topKey);\n            if (!target)\n                continue;\n            walk(topSchema, [topKey], target, 0);\n            if (added >= maxExtraItems)\n                break;\n        }\n    }\n    searchSettings(query) {\n        const q = this.normalizeText(query);\n        if (!q)\n            return [];\n        const scored = this._searchIndex.map(item => {\n            const key = this.normalizeText(item.key);\n            const title = this.normalizeText(item.title);\n            const desc = this.normalizeText(item.description);\n            let score = 0;\n            if (key === q)\n                score = 1000;\n            else if (key.startsWith(q))\n                score = 800;\n            else if (key.includes(q))\n                score = 600;\n            if (score === 0) {\n                if (title === q)\n                    score = 550;\n                else if (title.startsWith(q))\n                    score = 450;\n                else if (title.includes(q))\n                    score = 350;\n            }\n            if (score === 0 && desc.includes(q))\n                score = 200;\n            return { item, score };\n        }).filter(x => x.score > 0);\n        scored.sort((a, b) => b.score - a.score || a.item.title.localeCompare(b.item.title));\n        return scored.slice(0, 50).map(x => x.item);\n    }\n    renderSearchResults(query) {\n        if (!this._searchResultsEl)\n            return;\n        if (this._searchResults.length === 0) {\n            this._searchResultsEl.innerHTML = `<div class=\"settings-search-empty\">No results for \"${this.escapeHtml(query)}\"</div>`;\n            return;\n        }\n        this._searchResultsEl.innerHTML = this._searchResults.map((r, index) => {\n            const activeClass = index === this._searchSelectedIndex ? 'active' : '';\n            const meta = `${this.escapeHtml(r.categoryTitle || 'General')} • ${this.escapeHtml(r.key)}`;\n            return `\n                <div class=\"settings-search-result ${activeClass}\" role=\"option\" data-index=\"${index}\">\n                    <div class=\"settings-search-result-title\">${this.escapeHtml(r.title)}</div>\n                    <div class=\"settings-search-result-meta\">${meta}</div>\n                </div>\n            `;\n        }).join('');\n        this._searchResultsEl.querySelectorAll('.settings-search-result').forEach(el => {\n            el.addEventListener('mousedown', (e) => {\n                e.preventDefault();\n            });\n            el.addEventListener('click', () => {\n                const idx = Number(el.dataset.index);\n                const item = this._searchResults[idx];\n                if (item)\n                    this.navigateToSetting(item);\n            });\n        });\n    }\n    updateSearchActiveItem() {\n        if (!this._searchResultsEl)\n            return;\n        const nodes = Array.from(this._searchResultsEl.querySelectorAll('.settings-search-result'));\n        nodes.forEach((n, i) => {\n            if (i === this._searchSelectedIndex)\n                n.classList.add('active');\n            else\n                n.classList.remove('active');\n        });\n        const active = nodes[this._searchSelectedIndex];\n        if (active) {\n            active.scrollIntoView({ block: 'nearest' });\n        }\n    }\n    navigateToSetting(item) {\n        const settingEl = document.getElementById(`setting-${item.propertyDomId}`);\n        if (!settingEl)\n            return;\n        document.querySelectorAll('.property-item.search-target').forEach(el => el.classList.remove('search-target'));\n        settingEl.classList.add('search-target');\n        settingEl.scrollIntoView({ block: 'center', behavior: 'smooth' });\n        const control = settingEl.querySelector('[data-key]');\n        if (control && 'focus' in control) {\n            control.focus();\n        }\n        window.setTimeout(() => settingEl.classList.remove('search-target'), 1400);\n        this.hideSearchResults();\n    }\n    escapeHtml(value) {\n        return String(value || '')\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    }\n    log(level, text, data) {\n        const payload = {\n            command: 'log',\n            level,\n            text,\n            data,\n            meta: { sessionId: this._sessionId, ts: Date.now() }\n        };\n        // Webview 侧控制台（需要打开 VS Code Developer Tools 才能看到）\n        if (level === 'error')\n            console.error(`[SettingsEditorApp][${this._sessionId}] ${text}`, data);\n        else if (level === 'warn')\n            console.warn(`[SettingsEditorApp][${this._sessionId}] ${text}`, data);\n        else\n            console.log(`[SettingsEditorApp][${this._sessionId}] ${text}`, data);\n        // 同步把日志上报到扩展侧，方便在 Output/Extension Host 中查看\n        this.postMessage(payload);\n    }\n    debugLog(text, data) {\n        this.log('debug', text, data);\n    }\n    infoLog(text, data) {\n        this.log('info', text, data);\n    }\n    handleUpdateJsonAck(meta) {\n        const ok = !!meta?.ok;\n        const rev = typeof meta?.rev === 'number' ? meta.rev : undefined;\n        this.debugLog('recv updateJsonAck', { sessionId: this._sessionId, meta });\n        if (!ok) {\n            this.log('warn', 'updateJsonAck not ok', { sessionId: this._sessionId, meta });\n            return;\n        }\n        if (typeof rev !== 'number') {\n            return;\n        }\n        if (rev < this._lastAckRev) {\n            this.debugLog('ignore updateJsonAck (rev older than lastAckRev)', {\n                sessionId: this._sessionId,\n                rev,\n                lastAckRev: this._lastAckRev\n            });\n            return;\n        }\n        this._lastAckRev = rev;\n        // 仅当 ack 对应“最新一次发送”时，才提升 baseData，避免乱序 ack 覆盖新状态\n        if (rev !== this._lastSentRev) {\n            this.debugLog('updateJsonAck rev not latest, skip baseData update', {\n                sessionId: this._sessionId,\n                rev,\n                lastSentRev: this._lastSentRev\n            });\n            return;\n        }\n        this._baseData = this.cloneJson(this.data);\n        this._dirtyPaths.clear();\n        this._dirtyCollectionPaths.clear();\n        this.debugLog('baseData updated & dirty sets cleared (after ack)', {\n            sessionId: this._sessionId,\n            rev,\n            uri: meta?.uri,\n            version: meta?.version\n        });\n    }\n    showError(error) {\n        this.log('error', 'showError', { sessionId: this._sessionId, error });\n    }\n    postMessage(message) {\n        if (window.vscode) {\n            window.vscode.postMessage(message);\n        }\n    }\n}\nnew SettingsEditorApp();\n\n\n\n//# sourceURL=webpack://general-settings-ui/./webview/main.ts?\n}");

/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./webview/main.ts"](0,__webpack_exports__,__webpack_require__);
/******/ 	
/******/ })()
;